<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
    <script>
        // branch 복습
        /*if( confirm('Go? Stop?') ){  // confirm은 정말로 그렇게 할 것인지 사용자에게 물을 때 사용. (☆삭제 기능을 사용할 때 꼭 사용할 것!)
            // 확인 버튼
            alert('확인');
        } else {
            // 취소 버튼
            alert('취소');
        }*/

        // 배열 복습. []로 묶여 있는 게 배열
        /*
        var arr = ['문자열', 1, 1.5, true, function(){alert('호호호');}];  // 배열에 익명함수도 저장할 수 있다.
        alert(arr.length);
        alert(arr[0]);  // 배열의 첫번째 요소
        (arr[4])();  // 배열의 마지막 요소. 그런데 함수라서... 함수 호출할 때는 뒤에 () 필요. 앞에도 () 넣어줌.
        */

        // function 복습
        /*
        fnGetList();  // 먼저 호출하더라도 문제가 없음. 선언 함수의 경우 호이스팅 대상이기 때문에

        function fnGetList(){   // 선언 함수(호이스팅)
            alert('하하하');
        }
        function fnGetList(){   // 선언 함수(호이스팅)
            alert('호호호');
        }
        fnGetList();
        
        // 익명함수
        var f = function(){   // 익명함수는 호이스팅 아님! function의 선언과 호출의 순서를 잘 맞춰야 한다.
            alert('하하하');
        }
        var f = () => {       // 화살표 함수
            alert('호호호');
        }
        f(); // 익명함수의 경우 실행을 하려면 변수에 저장해서 실행하는 방식을 써야한다.
        */
        /*
        // 함수를 매개변수에 저장할 수도 있다.
        function fnGetList(data){   // 일반적인 매개변수는 int data 처럼 타입이 붙는데, 자바스크립트는 변수명만 적어주면 된다.
            data();     // 전달된 함수는 매개변수명의 이름을 함수로 쓰면 사용할 수 있다.
        }
        fnGetList(function(){alert('하하하');});  // 익명함수 인수로 넣어주기 -> function이 data(매개변수)에 저장된 것.
        // ★ 이렇게 함수를 다른 함수의 매개변수에 전달해 주는 것을 callback이라 한다.
        */
    </script>

    <script>

        /*
            1. setTimeout
                1) 한 번만 동작하는 타이머 함수이다.
                2) 동작 (인수가 2개. 자기의 id를 리턴함)
                    var id = setTimeout(동작할함수, 동작할시간(밀리초));    // 동작할함수가 들어가는데 이게 callback이다. (선언, 익명함수 둘다 가능한데 수업에서는 익명함수 쓸거임.)
                3) 동작 취소 (id가 여기서 쓰인다.)
                    clearTimeout(id);
        */
        /*
        var timerId = setTimeout(function(){
            console.log('5초 지났다.');
        }, 5000); // 5초 후에 펑션이 동작한다.

        clearTimeout(timerId);  // 이제 더이상 동작하지 않음.
        */

    </script>

    <script>
        /*
            2. setInterval
                1) 반복해서 동작하는 타이머 함수이다.
                2) 동작
                    var id = setInterval(동작할함수, 동작할시간(밀리초));
                3) 동작 취소
                    clearInterval(id);
        */
        /*
        var n = 0;
        var timerId = setInterval(function(){
            console.log(n++);
        }, 1000);   // 1초마다 반복함
        clearInterval(timerId);
        */
    </script>
    <h1 id="timer1"></h1>
    <script>
        /*

        // 5초 타이머 구현하기(5 → 4 → 3 → 2 → 1 → 땡)
        var countDown = 5;
        var timer1 = document.getElementById('timer1');
        var timerId = setInterval(function(){
            if(countDown == 0) {
                timer1.textContent = '땡';
                clearInterval(timerId);
            } else {
                timer1.textContent = countDown--;
            }
        }, 1000);
        */
    </script>

    <script>
        /*
        정의해둔 함수는 실행을 위해서 호출해준다. 정의와 호출이 나누어져 있음. 
        호출부가 정의부에 들어 있는 것을 재귀호출이라고 한다.(자기가 자기를 부르는 것)
        최초 호출을 하면 실행을 한다. 
        */
       
        /*
            재귀 호출 예시 : factorial 구하기 (5! = 5*4*3*2*1)
            <규칙을 찾는 과정>
                5! = 5 * 4!    fnFactorial(5) = 5 * fnFactorial(4)
                4! = 4 * 3!    fnFactorial(4) = 4 * fnFactorial(3)  함수 호출 안에서 함수가 호출 되는 것
                3! = 3 * 2!    fnFactorial(3) = 3 * fnFactorial(2)
                2! = 2 * 1!    fnFactorial(2) = 2 * fnFactorial(1)
                1! = 1         fnFactorial(1) = 1
            ------------------------------------------------------
                               fnFactorial(n) = n * fnFactorial(n - 1);
            // ※ 자바스크립트 함수이름은 어떤 규칙으로 만들 지 정해두는 것 (fn + _을 붙여도 되고, 카멜케이스로 만들어도 되고)
        */
       function fnFactorial(n){
            if(n == 1) {
                return 1;
            } else {
                return n * fnFactorial(n - 1);
            }
       }

       console.log(fnFactorial(5));
       /*
        function ex(){
        console.log('하하하');
        ex();  // 재귀 호출(recursive call). 반복적인 일을 호출할 때 사용함. / 알고리즘에서 재귀호출 많이 나옴.
       }

       ex();
        */

    </script>

    <h1 id="timer2"></h1>
    <script>

        // 5초 타이머 구현하기(5 → 4 → 3 → 2 → 1 → 땡)
        // 정의

        var timer2 = document.getElementById('timer2')
        function fnTimer(countDown){
            setTimeout(function(){ if(countDown == 0) {
                                        timer2.textContent = '땡'
                                        // return; // function이 끝나는 것임(setTimeout에 전달된 익명 함수(콜백)를 종료한다.)
                                        // else로 처리했기 때문에(이거아니면 저거) return이 필요가 없다.
                                        // clear하는 게 의미가 없다. 어차피 1번 실행(Interval하고 달라서)
                                    } else {
                                        timer2.textContent = countDown;
                                        fnTimer(countDown -1);
                                    }
                                 }, 1000);
        }
        // 호출
        fnTimer(5);
        // Interval은 내부 스택을 잡고 쓰기 때문에 한참 쓰면 시간이 안 맞게 된다. setTimeout은 반환을 하기 때문에 더 괜찮다..?

    </script>



</body>
</html>